<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Draft21</title>

  <!-- ğŸ“± ××™×™×§×•× ×™× ×œ×©××™×¨×” ×‘-Home Screen -->
  <link rel="icon" type="image/png" href="draft21icon.png">
  <link rel="apple-touch-icon" href="draft21icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="draft21icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="draft21icon.png">
  <link rel="icon" type="image/png" sizes="512x512" href="draft21icon.png">

  <!-- PWA - ×©× ×”××¤×œ×™×§×¦×™×” ×‘×”×•× ×¡×§×¨×™×Ÿ -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Draft21">
  <meta name="application-name" content="Draft21">
  <meta name="theme-color" content="#3b82f6">

  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-20px); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    @keyframes fall { to { transform: translateY(100vh) rotate(360deg); opacity: 0; } }
    .animate-bounce { animation: bounce 1s infinite; }
    .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    .confetti { position: fixed; animation: fall 3s linear; pointer-events: none; font-size: 24px; z-index: 9999; }
  </style>
</head>
<body class="min-h-screen">
  <div id="app">
    <div class="min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center p-4">
      <div class="bg-white rounded-3xl shadow-2xl p-8 text-center">
        <div class="text-6xl mb-4 animate-bounce">ğŸ†</div>
        <h1 class="text-3xl font-bold text-gray-800 mb-2">Draft21</h1>
        <div class="animate-pulse text-gray-600">×˜×•×¢×Ÿ ××ª ×”××¢×¨×›×ª...</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, doc, onSnapshot, setDoc, updateDoc, runTransaction, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    const app = initializeApp({
      apiKey: "AIzaSyBqz4oHoqGtnzjWqgzjWmwsUv6Kny75QpM",
      authDomain: "draft21-eabc3.firebaseapp.com",
      projectId: "draft21-eabc3",
      storageBucket: "draft21-eabc3.firebasestorage.app",
      messagingSenderId: "489648686113",
      appId: "1:489648686113:web:94d3605a0e5a871a434f60",
    });

    const db = getFirestore(app);
    const COLORS = { Red: 'bg-red-500', White: 'bg-gray-100', Black: 'bg-gray-900' };

    // =========================
    // Local UI/session state
    // =========================
    let S = {
      phase: 'setup', input: '', nick: '', id: '', host: false,
      caps: [], assigns: {}, order: [], manual: false, manualColors: true
    };

    // =========================
    // Helpers (order + bounce)
    // =========================

    // One "bounce" step: 0â†’1â†’2â†’2â†’1â†’0â†’0â†’1â†’2â†’2...
    function stepBounce(pos, dir, len) {
      if ((pos === len - 1 && dir === 1) || (pos === 0 && dir === -1)) {
        // At an end -> flip direction, stay on same index (double pick)
        dir = -dir;
      } else {
        pos = pos + dir; // move one
      }
      return { pos, dir };
    }

    // Is a team full (7 players including captain)?
    function teamIsFull(teams, name) {
      const t = teams.find(tm => tm.name === name);
      return t ? t.players.length >= 7 : true;
    }

    // Advance to the next team that is NOT full, with bounce behavior.
    function advanceToNextOpenTeam(order, pos, dir, teams) {
      const len = order.length || 0;
      if (!len) return { pos: 0, dir: 1 };
      let guard = 0;
      ({ pos, dir } = stepBounce(pos, dir, len)); // always try to move once
      while (guard < len * 4 && teamIsFull(teams, order[pos])) {
        ({ pos, dir } = stepBounce(pos, dir, len));
        guard++;
      }
      return { pos, dir };
    }

    // Is current user the CAPTAIN of the current team?
    // Here we define "captain user" as the participant whose nick equals the captain's name.
    function isMyTeamAndIAmCaptain(gd, teamName) {
      const my = gd.participants.find(p => p.id === S.id);
      const tm = gd.teams.find(t => t.name === teamName);
      if (!my || !tm) return false;
      return my.teamName === teamName && my.nick === tm.captain;
    }

    // =========================
    // Boot + live updates
    // =========================
    function init() {
      const n = localStorage.getItem('d21_nick');
      const i = localStorage.getItem('d21_id');
      if (n) S.nick = n;
      if (i) S.id = i;
      if (localStorage.getItem('d21_host') === '1') S.host = true;
      try {
        const c = localStorage.getItem('d21_caps');
        const a = localStorage.getItem('d21_assign');
        if (c) S.caps = JSON.parse(c);
        if (a) S.assigns = JSON.parse(a);
      } catch (e) {}

      onSnapshot(doc(db, 'games', 'current'), snap => {
        if (snap.exists()) S.phase = snap.data().status || 'setup';
        render();
      });
    }

    // =========================
    // Setup screen
    // =========================
    function clean(t) {
      return t
        .split('\n')
        .map(l => l.trim().replace(/^\d+[\.\)\-\s]+/,'').replace(/[\d\.\)\-]+$/,'').replace(/\d+/g,'').trim())
        .filter(n => n.length > 0)
        .slice(0,21);
    }

    async function initGame() {
      const names = clean(S.input);
      if (!names.length) return;
      const plrs = names.map((n,i) => ({id:'p'+i, name:n, available:true}));
      await setDoc(doc(db,'games','current'), {
        status:'captains', players:plrs, teams:[], participants:[], picks:[],
        turn:{order:[],index:0,direction:1}, settings:{snake:true}, pendingPick:null, lastPick:null
      });
      S.host = true;
      localStorage.setItem('d21_host','1');
    }

    // =========================
    // Captains
    // =========================
    function togCap(id) {
      const i = S.caps.indexOf(id);
      if (i > -1) S.caps.splice(i,1);
      else if (S.caps.length < 3) S.caps.push(id);
      localStorage.setItem('d21_caps', JSON.stringify(S.caps));
      render();
    }

    async function randCaps() {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const av = snap.data().players.filter(p => p.available);
      const sh = av.slice().sort(() => Math.random()-.5);
      S.caps = sh.slice(0,3).map(p => p.id);
      if (!S.manualColors) {
        const cols = ['Red','White','Black'].sort(() => Math.random()-.5);
        S.assigns = {};
        S.caps.forEach((c,i) => S.assigns[c] = cols[i]);
        localStorage.setItem('d21_assign', JSON.stringify(S.assigns));
      }
      localStorage.setItem('d21_caps', JSON.stringify(S.caps));
      render();
    }

    function assignT(cid, col) {
      S.assigns[cid] = col;
      localStorage.setItem('d21_assign', JSON.stringify(S.assigns));
      render();
    }

    function togColorsMode() {
      S.manualColors = !S.manualColors;
      if (!S.manualColors && S.caps.length === 3) {
        const cols = ['Red','White','Black'].sort(() => Math.random()-.5);
        S.assigns = {};
        S.caps.forEach((c,i) => S.assigns[c] = cols[i]);
        localStorage.setItem('d21_assign', JSON.stringify(S.assigns));
      }
      render();
    }

    function randColors() {
      if (S.caps.length === 3) {
        const cols = ['Red','White','Black'].sort(() => Math.random()-.5);
        S.assigns = {};
        S.caps.forEach((c,i) => S.assigns[c] = cols[i]);
        localStorage.setItem('d21_assign', JSON.stringify(S.assigns));
        render();
      }
    }

    async function finCaps() {
      if (S.caps.length !== 3 || Object.keys(S.assigns).length !== 3) return;
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const tms = S.caps.map(cid => {
        const cap = gd.players.find(p => p.id === cid);
        return {name:S.assigns[cid], captain:cap.name, captainId:cid, players:[cap.name]};
      });
      const up = gd.players.map(p => ({...p, available:!S.caps.includes(p.id)}));
      await updateDoc(doc(db,'games','current'), {teams:tms, players:up, status:'lobby'});
    }

    // =========================
    // Lobby
    // =========================
    async function joinLob() {
      if (!S.nick.trim()) return;
      const pid = S.id || 'p'+Date.now();
      S.id = pid;
      localStorage.setItem('d21_id', pid);
      localStorage.setItem('d21_nick', S.nick);

      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const ex = gd.participants.find(p => p.id === pid);
      const pdata = ex || {id:pid, nick:S.nick, ready:false, teamName:null};
      const nps = ex ? gd.participants.map(p => p.id === pid ? pdata : p) : [...gd.participants, pdata];
      await updateDoc(doc(db,'games','current'), {participants:nps});
    }

    async function selTeam(tn) {
      if (!S.id) return;
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const nps = gd.participants.map(p => p.id === S.id ? {...p, teamName:tn} : p);
      await updateDoc(doc(db,'games','current'), {participants:nps});
    }

    async function togReady() {
      if (!S.id) return;
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const my = gd.participants.find(p => p.id === S.id);
      if (!my || !my.teamName) return;
      const nps = gd.participants.map(p => p.id === S.id ? {...p, ready:!p.ready} : p);
      await updateDoc(doc(db,'games','current'), {participants:nps});
    }

    async function togMan() {
      S.manual = !S.manual;
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      if (S.manual && S.order.length === 0) {
        S.order = gd.teams.map(t => t.name);
      }
      render();
    }

    function moveO(tn, d) {
      const i = S.order.indexOf(tn);
      if (i === -1) return;
      const ni = i + d;
      if (ni < 0 || ni >= S.order.length) return;
      const tmp = S.order[ni];
      S.order[ni] = S.order[i];
      S.order[i] = tmp;
      render();
    }

    function randO() {
      S.order = S.order.slice().sort(() => Math.random()-.5);
      render();
    }

    // Start draft: USE THE DECIDED ORDER, and do NOT filter by ready.
    async function startD() {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();

      let ord = [];
      if (S.manual && S.order.length > 0) {
        ord = S.order.slice(); // the user's chosen first/second/third
      } else {
        ord = gd.teams.map(t => t.name).sort(() => Math.random()-.5);
      }

      await updateDoc(doc(db,'games','current'), {
        status:'draft',
        turn:{order:ord, index:0, direction:1} // start at team 0, forward
      });
    }

    function getTurn(gd) {
      if (gd.turn.order.length === 0) return null;
      const tn = gd.turn.order[gd.turn.index % gd.turn.order.length];
      const t = gd.teams.find(tm => tm.name === tn);
      if (!t) return null;
      // It's my turn ONLY if I am the CAPTAIN of this team:
      const isCaptainTurn = isMyTeamAndIAmCaptain(gd, tn);
      return {team:t, captain:t.captain, teamName:tn, isMyTurn:isCaptainTurn};
    }

    // =========================
    // Draft actions (ONLY CAPTAINS)
    // =========================
    async function makePk(pid) {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const ti = getTurn(gd);

      // Only the CAPTAIN of the current team may pick (no admin override)
      if (!ti || !ti.isMyTurn || gd.pendingPick) return;

      // prevent picking for a full team
      if (ti.team.players.length >= 7) return;

      const pl = gd.players.find(p => p.id === pid);
      if (!pl || !pl.available) return;

      await updateDoc(doc(db,'games','current'), {
        pendingPick:{
          playerId: pid,
          playerName: pl.name,
          teamName: ti.teamName,
          pickerId: S.id // the captain user id
        }
      });
    }

    async function confPk() {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();

      // Only the CAPTAIN who picked can confirm
      if (!gd.pendingPick || gd.pendingPick.pickerId !== S.id) return;

      await runTransaction(db, async t => {
        const ref = doc(db,'games','current');
        const s = await t.get(ref);
        if (!s.exists()) return;
        const gd = s.data();
        const pend = gd.pendingPick;
        if (!pend) return;

        const {playerId: pid, playerName: pn, teamName: tn} = pend;

        const curTeam = gd.teams.find(tm => tm.name === tn);
        if (!curTeam || curTeam.players.length >= 7) return;

        // Ensure confirmer is the CAPTAIN of this team
        if (!isMyTeamAndIAmCaptain(gd, tn)) return;

        const pl = gd.players.find(p => p.id === pid);
        if (!pl || !pl.available) return;

        // Apply the pick
        const upPlayers = gd.players.map(p => p.id === pid ? ({...p, available:false}) : p);
        const upTeams   = gd.teams.map(tm => tm.name === tn ? ({...tm, players:[...tm.players, pn]}) : tm);
        const picks     = [...gd.picks, {teamName:tn, playerName:pn}];

        // Finish condition: all players taken OR all teams >= 7 players
        const allTaken  = upPlayers.every(p => !p.available);
        const fullTeams = upTeams.every(t => t.players.length >= 7);

        // Compute next turn using BOUNCE (1,2,3,3,2,1,1,2,3,3,...) and SKIP FULL TEAMS
        const order = gd.turn.order;
        let pos     = gd.turn.index || 0;
        let dir     = gd.turn.direction || 1;

        let next = { pos, dir };
        if (!allTaken && !fullTeams) {
          next = advanceToNextOpenTeam(order, pos, dir, upTeams);
        }

        const update = {
          players: upPlayers,
          teams: upTeams,
          picks,
          pendingPick: null,
          lastPick: {playerName: pn, teamName: tn},
          turn: {order, index: next.pos, direction: next.dir}
        };

        if (allTaken || fullTeams) {
          update.status = 'complete';
        }

        t.update(ref, update);
      });
    }

    // Undo (kept for admin control/testing). Does not allow admin to make/confirm picks.
    async function undoPk() {
      // Admin-only UI button below; anyone calling this still just rewinds state.
      await runTransaction(db, async t => {
        const ref = doc(db,'games','current');
        const snap = await t.get(ref);
        if (!snap.exists()) return;
        const gd = snap.data();
        if (!gd.lastPick) return;

        const {playerName: pn, teamName: tn} = gd.lastPick;

        // Revert player availability
        const upPlayers = gd.players.map(p => p.name === pn ? ({...p, available:true}) : p);
        // Remove from team
        const upTeams   = gd.teams.map(tm => tm.name === tn ? ({...tm, players: tm.players.filter(x => x !== pn)}) : tm);
        // Remove last pick
        const picks = gd.picks.slice(0, -1);

        // Recompute turn by simulating bounce+skip from start based on current team rosters
        const order = gd.turn.order;
        const len   = order.length || 0;
        let pos = 0, dir = 1;

        // Build counts from teams (captain already counted)
        const counts = {};
        order.forEach(n => {
          const tm = upTeams.find(t => t.name === n);
          counts[n] = tm ? tm.players.length : 0;
        });

        // Find the next team that should pick by simulating picks.length steps
        // Each step: the team at [pos] picks (if not full), then advance.
        // Weâ€™ll fast-forward so that after processing 'picks' picks, (pos,dir) is the NEXT turn.
        // (Since 'picks' array already reflects the applied picks, we can just walk.)
        // Start from initial state: all captains counted, so we need to reconstruct the path:
        // Instead, simpler: start from (0,1) and advance 'picks.length' times using advanceToNextOpenTeam
        // as if each step consumed one pick.
        // To do that correctly, we need dynamic counts as we walk:
        for (let i = 0; i < picks.length; i++) {
          // The team who just picked is picks[i].teamName; but to be consistent with skipping,
          // we can just increment counts for that team then advance:
          const tmN = picks[i].teamName;
          counts[tmN] = (counts[tmN] || 0) + 0; // counts already reflect upTeams; no extra increment needed here
          const nd = advanceToNextOpenTeam(order, pos, dir, upTeams);
          pos = nd.pos; dir = nd.dir;
        }

        t.update(ref, {
          players: upPlayers,
          teams: upTeams,
          picks,
          lastPick: picks.length ? picks[picks.length - 1] : null,
          pendingPick: null,
          status: 'draft',
          turn: {order, index: pos, direction: dir}
        });
      });
    }

    async function canPend() {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      // Only the same captain who picked can cancel the pending pick
      if (!gd.pendingPick || gd.pendingPick.pickerId !== S.id) return;
      await updateDoc(doc(db,'games','current'), {pendingPick:null});
    }

    // =========================
    // Reset / Share
    // =========================
    async function rstDraft() {
      const snap = await getDoc(doc(db,'games','current'));
      if (!snap.exists()) return;
      const gd = snap.data();
      const up = gd.players.map(p => {
        const isC = gd.teams.some(t => t.captainId === p.id);
        return {...p, available:!isC};
      });
      const ut = gd.teams.map(t => ({...t, players:[t.captain]}));
      await updateDoc(doc(db,'games','current'), {
        status:'lobby', players:up, teams:ut, picks:[], pendingPick:null,
        lastPick:null, turn:{order:[], index:0, direction:1}
      });
      S.order = [];
      S.manual = false;
    }

    async function fullRst() {
      if (confirm('×”×× ××ª×” ×‘×˜×•×—? ×¤×¢×•×œ×” ×–×• ×ª××—×§ ××ª ×›×œ ×”× ×ª×•× ×™×!')) {
        await setDoc(doc(db,'games','current'), {
          status:'setup', players:[], teams:[], participants:[], picks:[],
          turn:{order:[],index:0,direction:1}, settings:{snake:true}, pendingPick:null, lastPick:null
        });
        localStorage.removeItem('d21_host');
        localStorage.removeItem('d21_caps');
        localStorage.removeItem('d21_assign');
        S.host = false;
        S.caps = [];
        S.assigns = {};
        S.order = [];
        S.manual = false;
        S.manualColors = true;
      }
    }

    function shareWA() {
      const snap = doc(db,'games','current');
      getDoc(snap).then(s => {
        if (!s.exists()) return;
        const gd = s.data();
        let txt = '*ğŸ† ×ª×•×¦××•×ª ×”×“×¨××¤×˜:*\n\n';
        gd.teams.forEach(t => {
          txt += `*${t.name}:*\n`;
          t.players.forEach(p => txt += `â€¢ ${p}\n`);
          txt += '\n';
        });
        window.open('https://wa.me/?text='+encodeURIComponent(txt));
      });
    }

    function confetti() {
      const emojis = ['ğŸ‰','ğŸŠ','âš½','ğŸ†','âœ¨','ğŸŒŸ'];
      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          const e = document.createElement('div');
          e.className = 'confetti';
          e.textContent = emojis[Math.floor(Math.random()*emojis.length)];
          e.style.left = Math.random()*100+'%';
          e.style.animationDuration = (2+Math.random()*2)+'s';
          document.body.appendChild(e);
          setTimeout(() => e.remove(), 3000);
        }, i*50);
      }
    }

    // =========================
    // Rendering
    // =========================
    function render() {
      getDoc(doc(db,'games','current')).then(snap => {
        let h = '';
        const gd = snap.exists() ? snap.data() : null;

        if (!gd || S.phase === 'setup') h = rSetup();
        else if (S.phase === 'captains') h = rCaps(gd);
        else if (S.phase === 'lobby') h = rLobby(gd);
        else if (S.phase === 'draft') h = rDraft(gd);
        else if (S.phase === 'complete') { h = rComp(gd); setTimeout(confetti,100); }

        document.getElementById('app').innerHTML = h;
      });
    }

    function rSetup() {
      let h = '<div class="min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 p-4"><div class="max-w-2xl mx-auto">'+
        '<div class="bg-white rounded-3xl shadow-2xl p-8"><div class="text-center mb-8">'+
        '<div class="text-7xl mb-4 animate-bounce">âš½</div><h1 class="text-4xl font-bold text-gray-800 mb-2">Draft21</h1>'+
        '<p class="text-gray-600">×›×œ×™ ×”×“×¨××¤×˜ ×”××•×œ×˜×™××˜×™×‘×™</p></div>';

      if (S.host) {
        h += '<div class="mb-4 text-center">'+
          '<button onclick="hFullR()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-red-600">ğŸ—‘ï¸ ××™×¤×•×¡ ××•×—×œ×˜</button>'+
          '</div>';
      }

      h += '<div class="space-y-6">'+
        '<div class="bg-gradient-to-r from-green-50 to-blue-50 rounded-2xl p-6 border-2 border-green-300">'+
        '<h3 class="text-xl font-bold mb-4 text-green-700">ğŸ“‹ ×”×›× ×¡ ××ª ×¨×©×™××ª ×”×©×—×§× ×™×</h3>'+
        '<textarea id="inp" placeholder="×”×“×‘×§ ×›××Ÿ ××ª ×”×¨×©×™××”...\n×©×—×§×Ÿ 1\n×©×—×§×Ÿ 2\n×©×—×§×Ÿ 3" class="w-full h-40 p-4 rounded-xl border-2 border-green-200" onkeyup="document.getElementById(\'cnt\').textContent=clean(this.value).length"></textarea>'+
        '<div class="flex justify-between items-center mt-3"><span class="text-sm text-green-600">×©×—×§× ×™×: <b id="cnt">0</b>/21</span>'+
        '<span class="text-xs text-gray-500">×”××¢×¨×›×ª ×ª× ×§×” ××¡×¤×¨×™× ××•×˜×•××˜×™×ª</span></div></div>'+
        '<button onclick="hInitG()" class="w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white py-4 rounded-xl font-bold text-lg hover:scale-105 transition">ğŸš€ ×”×ª×—×œ ××©×—×§ ×—×“×©</button>'+
        '</div></div></div></div>';
      return h;
    }

    function rCaps(gd) {
      let h = '<div class="min-h-screen bg-gradient-to-br from-purple-500 to-pink-600 p-4"><div class="max-w-4xl mx-auto">'+
        '<div class="bg-white rounded-3xl shadow-2xl p-8"><div class="text-center mb-8">'+
        '<h2 class="text-3xl font-bold mb-2">×‘×—×™×¨×ª ×§×¤×˜× ×™×</h2>'+
        '<p class="text-gray-600">×‘×—×¨ 3 ×§×¤×˜× ×™× ×•×”×§×¦×” ×œ×”× ×¦×‘×¢×™×</p></div>';

      if (S.host) {
        h += '<div class="mb-6 text-center">'+
          '<button onclick="hFullR()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-red-600">ğŸ—‘ï¸ ××™×¤×•×¡ ××•×—×œ×˜</button>'+
          '</div>';
      }

      h += '<div class="grid grid-cols-3 md:grid-cols-4 gap-3 mb-6">';
      gd.players.filter(p => p.available).forEach(p => {
        const sel = S.caps.includes(p.id);
        h += '<button onclick="hTogC(\''+p.id+'\')" class="p-4 rounded-xl font-medium '+(sel?'bg-blue-500 text-white':'bg-gray-100 text-gray-700 hover:bg-gray-200')+'">'+p.name+(sel?' âœ“':'')+'</button>';
      });
      h += '</div><div class="flex justify-center mb-6">'+
        '<button onclick="hRandC()" class="bg-purple-500 text-white px-6 py-3 rounded-xl font-bold hover:bg-purple-600">ğŸ² ×‘×—×™×¨×” ××§×¨××™×ª</button></div>';

      if (S.caps.length === 3) {
        h += '<div class="bg-gray-50 rounded-2xl p-6 mb-6">'+
          '<div class="flex items-center justify-between mb-4">'+
          '<h3 class="text-xl font-bold">×”×§×¦×” ×¦×‘×¢×™× ×œ×§×¤×˜× ×™×:</h3>'+
          '<button onclick="hTogColMode()" class="bg-blue-500 text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-blue-600">'+
          (S.manualColors ? 'ğŸ¯ ×™×“× ×™' : 'ğŸ² ××§×¨××™')+'</button></div>';

        if (S.manualColors) {
          h += '<div class="space-y-3">';
          S.caps.forEach(cid => {
            const cap = gd.players.find(p => p.id === cid);
            h += '<div class="bg-white rounded-xl p-4 border-2 border-gray-200"><h4 class="font-bold mb-2">'+cap.name+'</h4><div class="grid grid-cols-3 gap-2">';
            ['Red','White','Black'].forEach(col => {
              const ass = S.assigns[cid] === col;
              h += '<button onclick="hAssT(\''+cid+'\',\''+col+'\')" class="p-3 rounded-lg '+(ass?'ring-4 ring-blue-400':'hover:scale-105')+' transition">'+
                '<div class="w-8 h-8 rounded-full '+COLORS[col]+' mx-auto mb-1"></div>'+
                '<p class="text-xs font-medium">'+col+'</p></button>';
            });
            h += '</div></div>';
          });
          h += '</div>';
        } else {
          h += '<div class="bg-blue-50 rounded-xl p-4 border-2 border-blue-300">'+
            '<p class="text-blue-700 text-center mb-3">×”×¦×‘×¢×™× ×™×•×§×¦×• ××§×¨××™×ª</p>';

          if (Object.keys(S.assigns).length === 3) {
            h += '<div class="grid grid-cols-3 gap-3">';
            S.caps.forEach(cid => {
              const cap = gd.players.find(p => p.id === cid);
              const col = S.assigns[cid];
              h += '<div class="bg-white rounded-lg p-3 text-center">'+
                '<div class="w-12 h-12 rounded-full '+COLORS[col]+' mx-auto mb-2"></div>'+
                '<p class="font-bold text-sm">'+cap.name+'</p>'+
                '<p class="text-xs text-gray-600">'+col+'</p></div>';
            });
            h += '</div>';
          } else {
            h += '<button onclick="hRandCol()" class="w-full bg-blue-500 text-white py-3 rounded-xl font-bold hover:bg-blue-600 mt-3">ğŸ² ×”×’×¨×œ ×¦×‘×¢×™×</button>';
          }

          h += '</div>';
        }

        h += '</div>';
      }

      h += '<button onclick="hFinC()" '+(S.caps.length!==3||Object.keys(S.assigns).length!==3?'disabled':'')+' class="w-full bg-green-500 text-white py-4 rounded-xl font-bold text-lg disabled:bg-gray-300 disabled:cursor-not-allowed">'+
        'âœ“ ××™×©×•×¨ ×”×§×¤×˜× ×™× ('+S.caps.length+'/3, '+Object.keys(S.assigns).length+' ×¦×‘×¢×™×)</button>'+
        '</div></div></div>';
      return h;
    }

    function rLobby(gd) {
      const readyC = gd.participants.filter(p => p.ready && p.teamName).length;
      const rc = readyC;
      const my = S.id ? gd.participants.find(p => p.id === S.id) : null;

      let h = '<div class="min-h-screen bg-gradient-to-br from-teal-500 to-cyan-600 p-4"><div class="max-w-4xl mx-auto">'+
        '<div class="bg-white rounded-3xl shadow-2xl p-8"><div class="text-center mb-8">'+
        '<h2 class="text-3xl font-bold mb-2">ğŸ‘¥ ×œ×•×‘×™ ×”××ª× ×”</h2>'+
        '<p class="text-gray-600">×‘×—×¨×• ×¡×“×¨ ×œ×§×‘×•×¦×•×ª. ×”×“×¨××¤×˜ ×™×¨×•×¥ ×›×š: 1,2,3,3,2,1,1,2,3,3...</p></div>';

      if (S.host) {
        h += '<div class="mb-6 text-center space-x-2 flex gap-2 justify-center">'+
          '<button onclick="hRstD()" class="bg-orange-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-orange-600">ğŸ”„ ××¤×¡ ×“×¨××¤×˜</button>'+
          '<button onclick="hFullR()" class="bg-red-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-red-600">ğŸ—‘ï¸ ××™×¤×•×¡ ××•×—×œ×˜</button>'+
          '</div>';
      }

      if (!my) {
        h += '<div class="bg-blue-50 rounded-2xl p-6 mb-6 border-2 border-blue-300">'+
          '<h3 class="text-xl font-bold mb-3 text-blue-700">×”×¦×˜×¨×£ ×œ××©×—×§:</h3>'+
          '<input id="nickIn" type="text" placeholder="×”×›× ×¡ ××ª ×”×©× ×©×œ×š..." value="'+S.nick+'" class="w-full p-3 rounded-lg border-2 border-blue-200 mb-3">'+
          '<button onclick="hJoinL()" class="w-full bg-blue-500 text-white py-3 rounded-xl font-bold hover:bg-blue-600">ğŸ® ×›× ×™×¡×” ×œ××©×—×§</button></div>';
      }
      h += '<div class="mb-6"><h3 class="text-xl font-bold mb-3">ğŸ‘¥ ××©×ª×ª×¤×™× ('+gd.participants.length+'):</h3><div class="space-y-2">';
      gd.participants.forEach(p => {
        const tm = gd.teams.find(t => t.name === p.teamName);
        const isCap = tm && p.nick === tm.captain;
        h += '<div class="flex items-center justify-between p-3 rounded-xl bg-gray-50 border-2 '+(p.ready?'border-green-400':'border-gray-200')+'">'+
          '<div class="flex items-center gap-3">'+(p.teamName?'<div class="w-8 h-8 rounded-full '+COLORS[p.teamName]+'"></div>':'')+
          '<div><span class="font-medium block">'+p.nick+(isCap?' (×§×¤×˜×Ÿ)':'')+'</span>'+(tm?'<span class="text-xs text-gray-600">×§×‘×•×¦×”: '+tm.name+'</span>':'<span class="text-xs text-red-600">×œ× ×‘×—×¨ ×§×‘×•×¦×”</span>')+
          '</div></div>'+(p.ready?'<span class="text-2xl">âœ“</span>':'')+'</div>';
      });
      h += '</div></div>';
      if (my) {
        if (!my.teamName) {
          h += '<div class="mb-4 p-4 bg-yellow-50 border-2 border-yellow-300 rounded-xl">'+
            '<p class="font-bold text-yellow-800 mb-3 text-center">×‘×—×¨ ××ª ×”×§×‘×•×¦×” ×©×œ×š:</p><div class="grid grid-cols-3 gap-3">';
          gd.teams.forEach(t => {
            const taken = gd.participants.some(p => p.teamName === t.name && p.id !== S.id && p.nick === t.captain);
            h += '<button onclick="hSelT(\''+t.name+'\')" '+(taken?'disabled':'')+' class="p-4 rounded-xl '+(taken?'bg-gray-200 opacity-50 cursor-not-allowed':'bg-white border-2 border-gray-300 hover:border-blue-500')+'">'+
              '<div class="w-12 h-12 rounded-full '+COLORS[t.name]+' mx-auto mb-2"></div>'+
              '<p class="font-bold text-sm">'+t.name+'</p><p class="text-xs text-gray-600">'+t.captain+'</p>'+(taken?'<p class="text-xs text-red-600 mt-1">×”×§×¤×˜×Ÿ ×›×‘×¨ ×ª×¤×¡</p>':'')+'</button>';
          });
          h += '</div></div>';
        }
        h += '<button onclick="hTogR()" '+(!my.teamName?'disabled':'')+' class="w-full py-4 rounded-xl font-bold mb-4 '+(!my.teamName?'bg-gray-200 text-gray-400 cursor-not-allowed':my.ready?'bg-gray-300 text-gray-700':'bg-green-500 text-white hover:bg-green-600')+'">'+(my.ready?'×‘×™×˜×•×œ ××•×›×Ÿ':my.teamName?'×× ×™ ××•×›×Ÿ!':'×‘×—×¨ ×§×‘×•×¦×” ×§×•×“×')+'</button>';
      }
      if (S.host && gd.teams.length === 3) {
        h += '<div class="border-t-2 pt-6 mt-6"><h3 class="text-xl font-bold mb-4">×¡×“×¨ ×”×§×‘×•×¦×•×ª</h3><div class="mb-4">'+
          '<button onclick="hTogMan()" class="w-full py-3 rounded-xl font-medium '+(S.manual?'bg-purple-500 text-white':'bg-gray-200 text-gray-700')+'">'+(S.manual?'âœ“ ×¡×“×¨ ×™×“× ×™ ×¤×¢×™×œ':'×¡×“×¨ ××§×¨××™ (×œ×—×¥ ×œ×¡×“×¨ ×™×“× ×™)')+'</button></div>';
        if (S.manual && S.order.length > 0) {
          h += '<div class="bg-gray-50 rounded-xl p-4 mb-4"><div class="flex items-center justify-between mb-3">'+
            '<h4 class="font-bold text-gray-700">×‘×—×¨ ×¨××©×•×Ÿ/×©× ×™/×©×œ×™×©×™</h4>'+
            '<button onclick="hRandO()" class="text-sm bg-purple-100 text-purple-700 px-3 py-1 rounded-lg hover:bg-purple-200">ğŸ”€ ×¢×¨×‘×‘</button></div>'+
            '<p class="text-xs text-gray-500 mb-3">×”×“×¨××¤×˜ ×™×¨×•×¥ ×›×š: 1,2,3,3,2,1,1,2,3,3...</p><div class="space-y-2">';
          S.order.forEach((tn,idx) => {
            const tm = gd.teams.find(t => t.name === tn);
            if (tm) {
              h += '<div class="flex items-center gap-2 bg-white p-3 rounded-lg"><span class="font-bold text-lg text-gray-500 w-8">'+(idx+1)+'.</span>'+
                '<div class="w-8 h-8 rounded-full '+COLORS[tn]+'"></div><div class="flex-1">'+
                '<span class="font-bold">'+tn+'</span><span class="text-sm text-gray-500 mr-2">('+tm.captain+')</span></div>'+
                '<div class="flex gap-1"><button onclick="hMoveO(\''+tn+'\',-1)" '+(idx===0?'disabled':'')+' class="w-8 h-8 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-30">â†‘</button>'+
                '<button onclick="hMoveO(\''+tn+'\',1)" '+(idx===S.order.length-1?'disabled':'')+' class="w-8 h-8 bg-gray-200 rounded hover:bg-gray-300 disabled:opacity-30">â†“</button></div></div>';
            }
          });
          h += '</div></div>';
        }
        h += '</div>';
      }
      if (S.host) {
        h += '<button onclick="hStartD()" class="w-full bg-gradient-to-r from-orange-500 to-red-600 text-white py-4 rounded-xl font-bold text-lg flex items-center justify-center gap-2">â–¶ï¸ ×”×ª×—×œ ×“×¨××¤×˜</button>';
      }
      h += '</div></div></div>';
      return h;
    }

    function rDraft(gd) {
      const ti = getTurn(gd);
      let h = '<div class="min-h-screen bg-gradient-to-br from-green-600 to-teal-600 p-4"><div class="max-w-6xl mx-auto">';
      if (ti) {
        h += '<div class="mb-6 p-6 rounded-3xl shadow-xl '+(ti.isMyTurn?'bg-yellow-400 animate-pulse':'bg-white')+'">'+
          '<div class="text-center"><p class="text-2xl font-bold mb-2">'+(ti.isMyTurn?'ğŸ”¥ ×”×ª×•×¨ ×©×œ×š ×œ×‘×—×•×¨! ğŸ”¥':'â³ ×”×ª×•×¨ ×©×œ: '+ti.captain)+'</p>'+
          '<p class="text-lg font-medium">×§×‘×•×¦×”: <span class="font-bold">'+ti.team.name+'</span></p>'+
          '<div class="mt-2 inline-flex items-center gap-2 text-xs '+(ti.isMyTurn?'text-gray-700':'text-green-600')+' bg-white bg-opacity-50 px-3 py-1 rounded-full">'+
          '<div class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></div>××¡×•× ×›×¨×Ÿ ×‘×–××Ÿ ×××ª</div></div></div>';
      }
      if (gd.pendingPick) {
        const canConfirm = gd.pendingPick.pickerId === S.id; // only the captain who picked
        h += '<div class="mb-6 p-6 rounded-2xl bg-orange-100 border-4 border-orange-400 shadow-xl">'+
          '<div class="text-center"><p class="text-lg font-bold text-orange-800 mb-3">âœ“ × ×‘×—×¨: '+gd.pendingPick.playerName+'</p>';
        if (canConfirm) {
          h += '<div class="flex gap-3 justify-center">'+
            '<button onclick="hConfP()" class="bg-green-500 text-white px-8 py-3 rounded-xl font-bold hover:bg-green-600">âœ“ ×¡×™×™××ª×™ - ×¢×‘×•×¨ ×œ×ª×•×¨ ×”×‘×</button>'+
            '<button onclick="hCanPend()" class="bg-gray-400 text-white px-6 py-3 rounded-xl font-bold hover:bg-gray-500">âœ— ×‘×˜×œ ×‘×—×™×¨×”</button>'+
            '</div>';
        } else {
          h += '<p class="text-sm text-gray-600 mt-2">×××ª×™× ×™× ×œ××™×©×•×¨ ×”×§×¤×˜×Ÿ...</p>';
        }
        h += '</div></div>';
      }
      h += '<div class="bg-white rounded-3xl shadow-2xl p-6 mb-6"><div class="flex items-center justify-between mb-4">'+
        '<h3 class="text-2xl font-bold">×©×—×§× ×™× ×–××™× ×™×</h3>';
      if (S.host && gd.lastPick) {
        h += '<button onclick="hUndoP()" class="bg-red-100 text-red-700 px-4 py-2 rounded-lg font-bold hover:bg-red-200">â†¶ ××—×•×¨×”</button>';
      }
      h += '</div><div class="grid grid-cols-2 md:grid-cols-4 gap-3">';
      gd.players.filter(p => p.available).forEach(pl => {
        const canP = ti && ti.isMyTurn && !gd.pendingPick; // ONLY captain of current team
        const isPend = gd.pendingPick && gd.pendingPick.playerId === pl.id;
        h += '<button onclick="hMakePk(\''+pl.id+'\')" '+(!canP?'disabled':'')+' class="p-4 rounded-xl border-2 '+(isPend?'bg-orange-400 text-white border-orange-600 scale-105 animate-pulse':canP?'bg-gradient-to-br from-blue-400 to-purple-500 text-white border-purple-600 hover:scale-105':'bg-gray-100 text-gray-500 border-gray-300 cursor-not-allowed')+'">'+pl.name+'</button>';
      });
      h += '</div></div><div class="grid md:grid-cols-3 gap-4 mb-6">';
      gd.teams.forEach(t => {
        h += '<div class="bg-white rounded-3xl shadow-xl p-6">'+
          '<div class="w-12 h-12 rounded-full '+COLORS[t.name]+' mx-auto mb-3"></div>'+
          '<h3 class="text-xl font-bold text-center mb-2">'+t.name+'</h3>'+
          '<p class="text-sm text-gray-600 text-center mb-4">×§×¤×˜×Ÿ: '+t.captain+'</p><div class="space-y-2">';
        t.players.forEach(p => {
          h += '<div class="bg-gray-100 p-2 rounded-lg text-center text-sm">'+p+'</div>';
        });
        h += '</div>'+
          '<p class="text-center text-xs text-gray-500 mt-3">×¡×”×´×›: '+t.players.length+'/7</p>'+
          '</div>';
      });
      h += '</div>';
      if (S.host) {
        h += '<div class="flex gap-2"><button onclick="hRstD()" class="flex-1 bg-red-500 text-white py-3 rounded-xl font-bold hover:bg-red-600">ğŸ”„ ××¤×¡ ×“×¨××¤×˜</button>'+
          '<button onclick="hFullR()" class="px-4 bg-gray-500 text-white py-3 rounded-xl font-bold hover:bg-gray-600" title="××™×¤×•×¡ ××œ×">ğŸ—‘ï¸</button></div>';
      }
      h += '</div></div>';
      return h;
    }

    function rComp(gd) {
      let h = '<div class="min-h-screen bg-gradient-to-br from-yellow-400 to-orange-500 p-4"><div class="max-w-4xl mx-auto">'+
        '<div class="bg-white rounded-3xl shadow-2xl p-8 mb-6"><div class="text-center mb-8">'+
        '<div class="text-7xl mb-4 animate-bounce">ğŸ†</div><h2 class="text-4xl font-bold mb-2">×”×“×¨××¤×˜ ×”×¡×ª×™×™×!</h2>'+
        '<p class="text-gray-600">×”× ×” ×”×§×‘×•×¦×•×ª ×©×œ×›×</p></div><div class="grid md:grid-cols-3 gap-6 mb-8">';
      gd.teams.forEach(t => {
        h += '<div class="bg-gradient-to-br from-gray-50 to-gray-100 rounded-2xl p-6 border-4 border-gray-300">'+
          '<div class="w-16 h-16 rounded-full '+COLORS[t.name]+' mx-auto mb-4"></div>'+
          '<h3 class="text-2xl font-bold text-center mb-3">'+t.name+'</h3>'+
          '<div class="bg-yellow-100 border-2 border-yellow-400 rounded-lg p-3 mb-4">'+
          '<p class="text-center font-bold text-yellow-800">ğŸ‘‘ '+t.captain+'</p></div><div class="space-y-2">';
        t.players.filter(p => p !== t.captain).forEach(p => {
          h += '<div class="bg-white p-3 rounded-lg text-center border border-gray-200">'+p+'</div>';
        });
        h += '</div></div>';
      });
      h += '</div><div class="space-y-4">'+
        '<button onclick="hShareWA()" class="w-full bg-green-500 text-white py-4 rounded-xl font-bold text-lg hover:bg-green-600 flex items-center justify-center gap-2">ğŸ“¤ ×©×ª×£ ×‘×•×•××˜×¡××¤</button>';
      if (S.host) {
        h += '<div class="flex gap-2">'+
          '<button onclick="hRstD()" class="flex-1 bg-gray-500 text-white py-3 rounded-xl font-bold hover:bg-gray-600">ğŸ”„ ×”×ª×—×œ ×“×¨××¤×˜ ×—×“×©</button>'+
          '<button onclick="hFullR()" class="px-4 bg-red-500 text-white py-3 rounded-xl font-bold hover:bg-red-600" title="××™×¤×•×¡ ××œ×">ğŸ—‘ï¸</button></div>';
      }
      h += '</div></div></div></div>';
      return h;
    }

    // =========================
    // Expose handlers
    // =========================
    window.hInitG = () => { S.input = document.getElementById('inp').value; initGame(); };
    window.hTogC = togCap;
    window.hRandC = randCaps;
    window.hAssT = assignT;
    window.hFinC = finCaps;
    window.hJoinL = () => { S.nick = document.getElementById('nickIn').value; joinLob(); };
    window.hSelT = selTeam;
    window.hTogR = togReady;
    window.hTogMan = togMan;
    window.hMoveO = moveO;
    window.hRandO = randO;
    window.hStartD = startD;
    window.hMakePk = makePk;
    window.hConfP = confPk;
    window.hUndoP = undoPk;
    window.hCanPend = canPend;
    window.hRstD = rstDraft;
    window.hShareWA = shareWA;
    window.hFullR = fullRst;
    window.hTogColMode = togColorsMode;
    window.hRandCol = randColors;

    init();
  </script>
</body>
</html>
